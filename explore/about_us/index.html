<!doctype html>
<html lang="en">
  <head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-V2474V50XP"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-V2474V50XP');
    </script>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
      referrerpolicy="no-referrer"
    />

    <title>HermodLabs — Home Page</title>
    <meta
      name="description"
      content="HermodLabs builds a co-timing engine that proves streams are on the same clock before you subtract, compare, threshold, or interpret. Portable cancellation + diagnostics + proof-shaped certificates."
    />

    <!-- If D3 is not already loaded elsewhere, keep this. If it is, remove it. -->
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>

    <script type="importmap">
    {
      "imports": {
        "lit": "https://esm.run/lit"
      }
    }
    </script>

    <link rel="stylesheet" href="" id="main-css" />
    <script type="module" src="../../bootstrap.js"></script>

  </head>

<body>
<site-page>
<section class="about-page" aria-labelledby="about-page-title">
  <div class="about-page__inner">
    <h1 class="about-page__title" id="about-page-title">About HermodLabs</h1>

    <p class="about-page__lede">
      HermodLabs builds a co-timing engine: a platform for turning messy, drifting sensor streams into measurements you
      can trust.
    </p>

    <p class="about-page__text">
      If two streams aren't on the same clock, subtraction is not cancellation.
      It's a gamble.
    </p>

    <p class="about-page__text">
      The plots look convincing until they don't.
    </p>

    <p class="about-page__text">
      We focus on the failure you can't see in a screenshot: time.
    </p>

    <!-- Replace the two static images with the responsive D3 sketch -->
    <figure class="about-page__step-media" aria-label="Signals that look the same… almost (windowed alignment sketch).">
      <div id="viz-same-almost" style="max-width: 78ch;"></div>
    </figure>


    <script>
      (() => {
        const el = document.getElementById("viz-same-almost");
        if (!el || typeof d3 === "undefined") return;

        const T = {
          stroke: "rgba(0,0,0,0.60)",
          axis:   "rgba(0,0,0,0.45)",
          guide:  "rgba(0,0,0,0.35)",
          faint:  "rgba(0,0,0,0.25)",
          fillW:  "rgba(0,0,0,0.06)",
          text:   "rgba(0,0,0,0.70)"
        };

        const A = [
          [0, 0.00],[0.5,0.35],[1.0,0.60],[1.5,0.30],[2.0,-0.20],[2.5,-0.55],[3.0,-0.25],
          [3.5,0.15],[4.0,0.55],[4.5,0.30],[5.0,-0.10],[5.5,-0.38],[6.0,-0.18],[6.5,0.10],
          [7.0,0.35],[7.5,0.10],[8.0,-0.20],[8.5,0.22],[9.0,0.55],[9.5,0.25],[10,0.00]
        ];

        const B = [
          [0,0.08],[0.5,0.18],[1.0,0.05],[1.5,-0.10],[2.0,-0.30],[2.5,-0.48],[3.0,-0.35],
          [3.5,-0.05],[4.0,0.25],[4.5,0.55],[5.0,0.30],[5.5,-0.10],[6.0,-0.38],[6.5,-0.10],
          [7.0,0.20],[7.5,0.42],[8.0,0.10],[8.5,-0.05],[9.0,0.18],[9.5,0.05],[10,-0.02]
        ];

        const cfg = {
          xDomain: [0, 10],
          wL: 3.0,
          wR: 7.0,
          aspect: 700 / 260
        };

        function makeSVG(width) {
          const height = Math.max(220, Math.round(width / cfg.aspect));
          const margin = { top: 18, right: 18, bottom: 18, left: 18 };
          const innerW = width - margin.left - margin.right;
          const innerH = height - margin.top - margin.bottom;

          const svg = d3.create("svg")
            .attr("viewBox", `0 0 ${width} ${height}`)
            .attr("width", "100%")
            .attr("height", "auto")
            .attr("role", "img")
            .attr("aria-label", "Two signals A and B. Inside a shaded window W they look similar up to delay Δ; outside the window they drift and mismatch.")
            .style("display", "block");

          const defs = svg.append("defs");

          defs.append("marker")
            .attr("id", "arrow-end")
            .attr("viewBox", "0 0 10 10")
            .attr("refX", 9).attr("refY", 5)
            .attr("markerWidth", 7).attr("markerHeight", 7)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 0 0 L 10 5 L 0 10 z")
            .attr("fill", T.stroke);

          defs.append("marker")
            .attr("id", "arrow-start")
            .attr("viewBox", "0 0 10 10")
            .attr("refX", 1).attr("refY", 5)
            .attr("markerWidth", 7).attr("markerHeight", 7)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 10 0 L 0 5 L 10 10 z")
            .attr("fill", T.stroke);

          const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

          const yExtent = d3.extent([...A, ...B].map(d => d[1]));
          const yPad = 0.25;
          const yDomain = [yExtent[0] - yPad, yExtent[1] + yPad];

          const x = d3.scaleLinear().domain(cfg.xDomain).range([0, innerW]);
          const y = d3.scaleLinear().domain(yDomain).range([innerH, 0]);

          const railTop = 0;
          const railBot = innerH;

          g.append("rect")
            .attr("x", x(cfg.wL))
            .attr("y", railTop)
            .attr("width", x(cfg.wR) - x(cfg.wL))
            .attr("height", railBot - railTop)
            .attr("fill", T.fillW);

          g.append("line")
            .attr("x1", 0).attr("x2", innerW)
            .attr("y1", railTop).attr("y2", railTop)
            .attr("stroke", T.axis).attr("stroke-width", 1);

          g.append("line")
            .attr("x1", 0).attr("x2", innerW)
            .attr("y1", railBot).attr("y2", railBot)
            .attr("stroke", T.axis).attr("stroke-width", 1);

          const guideDash = "6 5";
          [cfg.wL, cfg.wR].forEach(v => {
            g.append("line")
              .attr("x1", x(v)).attr("x2", x(v))
              .attr("y1", railTop).attr("y2", railBot)
              .attr("stroke", T.guide)
              .attr("stroke-width", 1)
              .attr("stroke-dasharray", guideDash);
          });

          g.append("text")
            .attr("x", x(cfg.wL) + 10)
            .attr("y", railTop + 14)
            .attr("fill", T.text)
            .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
            //.text("W");

          const line = d3.line()
            .x(d => x(d[0]))
            .y(d => y(d[1]))
            .curve(d3.curveCatmullRom.alpha(0.7));

          g.append("path")
            .attr("d", line(A))
            .attr("fill", "none")
            .attr("stroke", "rgba(0,0,0,0.92)")
            .attr("stroke-width", 2.0);

          g.append("path")
            .attr("d", line(B))
            .attr("fill", "none")
            .attr("stroke", "rgba(0,0,0,0.92)")
            .attr("stroke-width", 2.0)
            .attr("stroke-dasharray", "8 6");

          g.append("text")
            .attr("x", 8).attr("y", 18)
            .attr("fill", T.text)
            .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//            .text("A");

          g.append("text")
            .attr("x", 8).attr("y", 34)
            .attr("fill", T.text)
            .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//            .text("B");

          const dY = railBot - 16;
          const dX1 = x(4.3), dX2 = x(5.1);

          g.append("line")
            .attr("x1", dX1).attr("x2", dX2)
            .attr("y1", dY).attr("y2", dY)
            .attr("stroke", "rgba(0,0,0,0.55)")
            .attr("stroke-width", 1.4)
            .attr("marker-start", "url(#arrow-start)")
            .attr("marker-end", "url(#arrow-end)");

          g.append("text")
            .attr("x", dX2 + 10)
            .attr("y", dY + 4)
            .attr("fill", T.text)
            .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//            .text("Δ");

          const xX = x(8.9);
          const yX = y(yDomain[1] - 0.15);
          const s = 14;

          g.append("line")
            .attr("x1", xX - s/2).attr("y1", yX - s/2)
            .attr("x2", xX + s/2).attr("y2", yX + s/2)
            .attr("stroke", "rgba(0,0,0,0.55)")
            .attr("stroke-width", 1.6);

          g.append("line")
            .attr("x1", xX - s/2).attr("y1", yX + s/2)
            .attr("x2", xX + s/2).attr("y2", yX - s/2)
            .attr("stroke", "rgba(0,0,0,0.55)")
            .attr("stroke-width", 1.6);

          const cY = railTop + 22;
          const cR = 7;
          const cX1 = x(8.65);
          const cX2 = x(9.05);

          [cX1, cX2].forEach((cx, i) => {
            g.append("circle")
              .attr("cx", cx).attr("cy", cY)
              .attr("r", cR)
              .attr("fill", "none")
              .attr("stroke", T.faint)
              .attr("stroke-width", 1.2);

            const dx = i === 0 ? 4.2 : 1.2;
            const dy = i === 0 ? -2.6 : -4.6;

            g.append("line")
              .attr("x1", cx).attr("y1", cY)
              .attr("x2", cx + dx).attr("y2", cY + dy)
              .attr("stroke", T.faint)
              .attr("stroke-width", 1.2)
              .attr("stroke-linecap", "round");
          });

          return svg.node();
        }

        function render() {
          const width = Math.max(320, Math.floor(el.getBoundingClientRect().width || 700));
          el.innerHTML = "";
          el.appendChild(makeSVG(width));
        }

        const ro = new ResizeObserver(() => render());
        ro.observe(el);
        render();
      })();
    </script>
  </div>
</section>


<!-- Hero / Feature Section -->
<section class="engine-hero" aria-labelledby="engine-hero-title">
  <div class="engine-hero__container">
    <header class="engine-hero__header">

      <h2 class="engine-hero__title" id="engine-hero-title">
        An engine that earns the right to act.
      </h2>

      <p class="engine-hero__lede">
        Five mechanisms make interpretation explicit, publicly checkable, and safer to deploy — covered by one or more patent applications.
      </p>

      <div class="engine-hero__cta">
        <a class="button button--primary" href="/explore/engine">Learn More</a>
      </div>
    </header>

    <ul class="engine-hero__grid" role="list" aria-label="Engine features">
      <li class="engine-feature">
        <a class="engine-feature__link" href="/explore/engine/features/co_timing_validity">
          <div class="engine-feature__top">
            <h3 class="engine-feature__title">Co-Timing Validity</h3>
            <span class="engine-feature__pill">Feature</span>
          </div>
          <p class="engine-feature__text">
            Validates timing relationships across sensors, transforms, and assumptions —
            so decisions aren’t built from mismatched moments.
          </p>
          <span class="engine-feature__action" aria-hidden="true">Learn more →</span>
        </a>
      </li>

      <li class="engine-feature">
        <a class="engine-feature__link" href="/explore/engine/features/interpretive_entitlement">
          <div class="engine-feature__top">
            <h3 class="engine-feature__title">Interpretive Entitlement</h3>
            <span class="engine-feature__pill">Feature</span>
          </div>
          <p class="engine-feature__text">
            Formalizes when an interpretation may be asserted and used by requiring explicit warrants —
            what assumptions were invoked and what would falsify them (in some embodiments).
          </p>
          <span class="engine-feature__action" aria-hidden="true">Learn more →</span>
        </a>
      </li>

      <li class="engine-feature">
        <a class="engine-feature__link" href="/explore/engine/features/public_criteria_correctness">
          <div class="engine-feature__top">
            <h3 class="engine-feature__title">Public Criteria Correctness</h3>
            <span class="engine-feature__pill">Feature</span>
          </div>
          <p class="engine-feature__text">
            Defines “correct” using shared, inspectable criteria — not private pipeline conventions —
            with receipts and replay identifiers so a second operator can reproduce the same pass/fail (or graded) decision on the same window.
          </p>
          <span class="engine-feature__action" aria-hidden="true">Learn more →</span>
        </a>
      </li>

      <li class="engine-feature">
        <a class="engine-feature__link" href="/explore/engine/features/construction_selection">
          <div class="engine-feature__top">
            <h3 class="engine-feature__title">Construction Selection</h3>
            <span class="engine-feature__pill">Feature</span>
          </div>
          <p class="engine-feature__text">
            Makes the chosen frame/model explicit — selecting the operative construction from a controlled set,
            with traceability (identifiers + receipts) for why that construction was selected.
          </p>
          <span class="engine-feature__action" aria-hidden="true">Learn more →</span>
        </a>
      </li>

      <li class="engine-feature engine-feature--wide">
        <a class="engine-feature__link" href="/explore/engine/features/multi_layer_permission_to_act_stack">
          <div class="engine-feature__top">
            <h3 class="engine-feature__title">Multi-Layer Permission-to-Act Stack</h3>
            <span class="engine-feature__pill">Feature</span>
          </div>
          <p class="engine-feature__text">
            Separates “can we infer?” from “may we act?” by stacking gates across validity, entitlement,
            policy, risk, and execution — actions proceed only when every required layer clears (when configured).
          </p>
          <span class="engine-feature__action" aria-hidden="true">Learn more →</span>
        </a>
      </li>
    </ul>

    <p class="engine-hero__note">
      Patent pending. Feature names reflect product behavior; underlying implementations may evolve. Coverage may vary by embodiment.
    </p>
  </div>
</section>






</site-page>
</body>
</html>




<script>
(() => {
  const host = document.getElementById("viz-delay-window");
  if (!host || typeof d3 === "undefined") return;

  const cfg = {
    xDomain: [0, 10],
    wL: 3.0,
    wR: 7.0,
    aspect: 1563 / 663,
    samples: 240
  };

  const T = {
    axis:  "rgba(0,0,0,0.45)",
    guide: "rgba(0,0,0,0.35)",
    faint: "rgba(0,0,0,0.20)",
    text:  "rgba(0,0,0,0.70)",
    ink:   "rgba(0,0,0,0.92)",
    win:   "rgba(0,0,0,0.06)",
    cue:   "rgba(0,0,0,0.55)"
  };

  // ---- TikZ-ish signal model (ported to JS) ----
  const f = (t) =>
    0.62 * Math.sin(1.05 * t) +
    0.20 * Math.sin(3.0 * t) +
    0.18 * Math.exp(-((t - 6.1) * (t - 6.1)) / 1.3);

  const Del = (t) => {
    if (t < cfg.wL) return 0.25 + 0.10 * Math.sin(2.0 * t);
    if (t <= cfg.wR) return 0.80;
    return 0.45 + 0.22 * Math.sin(1.4 * t);
  };

  const A = (t) => f(t);
  const B = (t) => f(t - Del(t)) + 0.02 * Math.sin(13 * t);
  const Dhat = (t) => Del(t) + 0.05 * Math.sin(6.0 * t);

  // unique marker ids to avoid collisions if you reuse this component
  const uid = `delaywin-${Math.random().toString(16).slice(2)}`;

  function makeSVG(width) {
    const height = Math.max(240, Math.round(width / cfg.aspect));

    const margin = { top: 16, right: 16, bottom: 16, left: 16 };
    const innerW = width - margin.left - margin.right;
    const innerH = height - margin.top - margin.bottom;

    const gap = Math.round(innerH * 0.10);
    const panelH = Math.round((innerH - gap) / 2);

    // sample points
    const ts = d3.range(cfg.samples + 1).map(i => {
      const t0 = cfg.xDomain[0], t1 = cfg.xDomain[1];
      return t0 + (i / cfg.samples) * (t1 - t0);
    });

    const topData = ts.map(t => ({ t, a: A(t), b: B(t) }));
    const botData = ts.map(t => ({ t, dh: Dhat(t) }));

    const x = d3.scaleLinear().domain(cfg.xDomain).range([0, innerW]);

    const aExtent = d3.extent(topData.flatMap(d => [d.a, d.b]));
    const aPad = 0.20;
    const yTop = d3.scaleLinear()
      .domain([aExtent[0] - aPad, aExtent[1] + aPad])
      .range([panelH, 0]);

    const dhExtent = d3.extent(botData.map(d => d.dh));
    const dhPad = 0.10;
    const yBot = d3.scaleLinear()
      .domain([dhExtent[0] - dhPad, dhExtent[1] + dhPad])
      .range([panelH, 0]);

    // ---- SVG (IMPORTANT: no height="auto" attribute) ----
    const svg = d3.create("svg")
      .attr("viewBox", `0 0 ${width} ${height}`)
      .attr("preserveAspectRatio", "xMidYMid meet")
      .attr("role", "img")
//      .attr(
//        "aria-label",
//        "Top: two streams A (solid) and B (dashed) with a trusted window W where the estimated delay is stable. Bottom: delay estimate Δ-hat(t) is approximately constant inside W."
//      )
      .style("display", "block")
      .style("width", "100%")
      .style("height", "auto");

    const defs = svg.append("defs");

    defs.append("marker")
      .attr("id", `${uid}-arrow`)
      .attr("viewBox", "0 0 10 10")
      .attr("refX", 9).attr("refY", 5)
      .attr("markerWidth", 7).attr("markerHeight", 7)
      .attr("orient", "auto")
      .append("path")
      .attr("d", "M 0 0 L 10 5 L 0 10 z")
      .attr("fill", T.cue);

    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

    // ---------- TOP PANEL ----------
    const gTop = g.append("g");

    gTop.append("rect")
      .attr("x", x(cfg.wL))
      .attr("y", 0)
      .attr("width", x(cfg.wR) - x(cfg.wL))
      .attr("height", panelH)
      .attr("fill", T.win);

    gTop.append("line")
      .attr("x1", 0).attr("x2", innerW)
      .attr("y1", 0).attr("y2", 0)
      .attr("stroke", T.axis).attr("stroke-width", 1);

    gTop.append("line")
      .attr("x1", 0).attr("x2", innerW)
      .attr("y1", panelH).attr("y2", panelH)
      .attr("stroke", T.axis).attr("stroke-width", 1);

    [cfg.wL, cfg.wR].forEach(v => {
      gTop.append("line")
        .attr("x1", x(v)).attr("x2", x(v))
        .attr("y1", 0).attr("y2", panelH)
        .attr("stroke", T.guide)
        .attr("stroke-width", 1)
        .attr("stroke-dasharray", "6 5");
    });

    gTop.append("text")
      .attr("x", x(cfg.wL) + 10)
      .attr("y", 14)
      .attr("fill", T.text)
      .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//      .text("W");

    const lineA = d3.line()
      .x(d => x(d.t))
      .y(d => yTop(d.a))
      .curve(d3.curveCatmullRom.alpha(0.7));

    const lineB = d3.line()
      .x(d => x(d.t))
      .y(d => yTop(d.b))
      .curve(d3.curveCatmullRom.alpha(0.7));

    gTop.append("path")
      .attr("d", lineA(topData))
      .attr("fill", "none")
      .attr("stroke", T.ink)
      .attr("stroke-width", 2);

    gTop.append("path")
      .attr("d", lineB(topData))
      .attr("fill", "none")
      .attr("stroke", T.ink)
      .attr("stroke-width", 2)
      .attr("stroke-dasharray", "8 6");

    gTop.append("text")
      .attr("x", 8).attr("y", 18)
      .attr("fill", T.text)
      .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//      .text("A (solid)");

    gTop.append("text")
      .attr("x", 8).attr("y", 34)
      .attr("fill", T.text)
      .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//      .text("B (dashed)");

    const cueY = panelH - 14;
    gTop.append("line")
      .attr("x1", x(cfg.wL) + 28)
      .attr("x2", x(cfg.wL) + 120)
      .attr("y1", cueY)
      .attr("y2", cueY)
      .attr("stroke", T.cue)
      .attr("stroke-width", 1.6)
      .attr("marker-end", `url(#${uid}-arrow)`);

    gTop.append("text")
      .attr("x", x(cfg.wL) + 128)
      .attr("y", cueY + 4)
      .attr("fill", T.text)
      .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//      .text("Δ̂");

    // ---------- BOTTOM PANEL ----------
    const gBot = g.append("g").attr("transform", `translate(0, ${panelH + gap})`);

    gBot.append("rect")
      .attr("x", x(cfg.wL))
      .attr("y", 0)
      .attr("width", x(cfg.wR) - x(cfg.wL))
      .attr("height", panelH)
      .attr("fill", T.win);

    gBot.append("line")
      .attr("x1", 0).attr("x2", innerW)
      .attr("y1", 0).attr("y2", 0)
      .attr("stroke", T.axis).attr("stroke-width", 1);

    gBot.append("line")
      .attr("x1", 0).attr("x2", innerW)
      .attr("y1", panelH).attr("y2", panelH)
      .attr("stroke", T.axis).attr("stroke-width", 1);

    [cfg.wL, cfg.wR].forEach(v => {
      gBot.append("line")
        .attr("x1", x(v)).attr("x2", x(v))
        .attr("y1", 0).attr("y2", panelH)
        .attr("stroke", T.guide)
        .attr("stroke-width", 1)
        .attr("stroke-dasharray", "6 5");
    });

    const yMid = yBot((yBot.domain()[0] + yBot.domain()[1]) / 2);
    gBot.append("line")
      .attr("x1", 0).attr("x2", innerW)
      .attr("y1", yMid).attr("y2", yMid)
      .attr("stroke", T.faint)
      .attr("stroke-width", 1);

    const lineDh = d3.line()
      .x(d => x(d.t))
      .y(d => yBot(d.dh))
      .curve(d3.curveCatmullRom.alpha(0.7));

    gBot.append("path")
      .attr("d", lineDh(botData))
      .attr("fill", "none")
      .attr("stroke", T.ink)
      .attr("stroke-width", 2);

    gBot.append("text")
      .attr("x", 8).attr("y", 18)
      .attr("fill", T.text)
      .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//      .text("Δ̂(t)");

    gBot.append("text")
      .attr("x", x(cfg.wR) - 64)
      .attr("y", panelH - 12)
      .attr("fill", T.text)
      .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//      .text("≈ const");

    return svg.node();
  }

  function render() {
    const w = Math.floor(host.getBoundingClientRect().width);
    if (!w) return; // avoid rendering during layout=0
    host.innerHTML = "";
    host.appendChild(makeSVG(Math.max(320, w)));
  }

  const ro = new ResizeObserver(() => render());
  ro.observe(host);
  render();
})();
</script>




<script>
(() => {
  const host = document.getElementById("viz-warp-streams");
  if (!host || typeof d3 === "undefined") return;

  const cfg = {
    xDomain: [0, 10],
    wL: 3.0,
    wR: 7.0,
    Dconst: 0.80,
    aspect: 1563 / 663,
    samples: 240
  };

  const T = {
    axis:  "rgba(0,0,0,0.45)",
    guide: "rgba(0,0,0,0.35)",
    text:  "rgba(0,0,0,0.70)",
    ink:   "rgba(0,0,0,0.92)",
    win:   "rgba(0,0,0,0.06)",
    cue:   "rgba(0,0,0,0.55)"
  };

  // ---- Signals (ported from TikZ) ----
  const f = (t) =>
    0.62 * Math.sin(1.05 * t) +
    0.20 * Math.sin(3.0 * t) +
    0.18 * Math.exp(-((t - 6.1) * (t - 6.1)) / 1.3);

  const A = (t) => f(t);
  // B is delayed version of A (plus tiny ripple)
  const B = (t) => f(t - cfg.Dconst) + 0.02 * Math.sin(13 * t);
  // Warped B: undo delay (lands on A's timebase), ripple phase shifts a bit
  const BW = (t) => f(t) + 0.02 * Math.sin(13 * (t + cfg.Dconst));

  const uid = `warp-${Math.random().toString(16).slice(2)}`;

  function makeSVG(width) {
    const height = Math.max(240, Math.round(width / cfg.aspect));
    const margin = { top: 16, right: 16, bottom: 16, left: 16 };
    const innerW = width - margin.left - margin.right;
    const innerH = height - margin.top - margin.bottom;

    // 3 rows: top panel, middle label band, bottom panel
    const midH = Math.max(28, Math.round(innerH * 0.14));
    const gap = Math.max(10, Math.round(innerH * 0.06));
    const panelH = Math.round((innerH - midH - 2 * gap) / 2);

    const x = d3.scaleLinear().domain(cfg.xDomain).range([0, innerW]);

    // sample points
    const ts = d3.range(cfg.samples + 1).map(i => {
      const t0 = cfg.xDomain[0], t1 = cfg.xDomain[1];
      return t0 + (i / cfg.samples) * (t1 - t0);
    });

    const topData = ts.map(t => ({ t, a: A(t), b: B(t) }));
    const botData = ts.map(t => ({ t, a: A(t), bw: BW(t) }));

    // shared y scale across panels so “before/after” reads honestly
    const yExtent = d3.extent([
      ...topData.flatMap(d => [d.a, d.b]),
      ...botData.flatMap(d => [d.a, d.bw])
    ]);
    const yPad = 0.20;
    const y = d3.scaleLinear()
      .domain([yExtent[0] - yPad, yExtent[1] + yPad])
      .range([panelH, 0]);

    // ---- SVG (no height="auto" attribute) ----
    const svg = d3.create("svg")
      .attr("viewBox", `0 0 ${width} ${height}`)
      .attr("preserveAspectRatio", "xMidYMid meet")
      .attr("role", "img")
//      .attr(
//        "aria-label",
//        "Top: A (solid) and delayed B (dashed) inside window W with misalignment Δ. Middle: warp operator. Bottom: A and warped B aligned on a common timebase."
//      )
      .style("display", "block")
      .style("width", "100%")
      .style("height", "auto");

    const defs = svg.append("defs");

    // arrowheads for the Δ double arrow
    defs.append("marker")
      .attr("id", `${uid}-arrow-end`)
      .attr("viewBox", "0 0 10 10")
      .attr("refX", 9).attr("refY", 5)
      .attr("markerWidth", 7).attr("markerHeight", 7)
      .attr("orient", "auto")
      .append("path")
      .attr("d", "M 0 0 L 10 5 L 0 10 z")
      .attr("fill", T.cue);

    defs.append("marker")
      .attr("id", `${uid}-arrow-start`)
      .attr("viewBox", "0 0 10 10")
      .attr("refX", 1).attr("refY", 5)
      .attr("markerWidth", 7).attr("markerHeight", 7)
      .attr("orient", "auto")
      .append("path")
      .attr("d", "M 10 0 L 0 5 L 10 10 z")
      .attr("fill", T.cue);

    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

    const lineTopA = d3.line()
      .x(d => x(d.t))
      .y(d => y(d.a))
      .curve(d3.curveCatmullRom.alpha(0.7));

    const lineTopB = d3.line()
      .x(d => x(d.t))
      .y(d => y(d.b))
      .curve(d3.curveCatmullRom.alpha(0.7));

    const lineBotA = d3.line()
      .x(d => x(d.t))
      .y(d => y(d.a))
      .curve(d3.curveCatmullRom.alpha(0.7));

    const lineBotBW = d3.line()
      .x(d => x(d.t))
      .y(d => y(d.bw))
      .curve(d3.curveCatmullRom.alpha(0.7));

    function drawPanel(gP, mode /* "before" | "after" */) {
      // window wash
      gP.append("rect")
        .attr("x", x(cfg.wL))
        .attr("y", 0)
        .attr("width", x(cfg.wR) - x(cfg.wL))
        .attr("height", panelH)
        .attr("fill", T.win);

      // rails
      gP.append("line")
        .attr("x1", 0).attr("x2", innerW)
        .attr("y1", 0).attr("y2", 0)
        .attr("stroke", T.axis).attr("stroke-width", 1);

      gP.append("line")
        .attr("x1", 0).attr("x2", innerW)
        .attr("y1", panelH).attr("y2", panelH)
        .attr("stroke", T.axis).attr("stroke-width", 1);

      // guides
      [cfg.wL, cfg.wR].forEach(v => {
        gP.append("line")
          .attr("x1", x(v)).attr("x2", x(v))
          .attr("y1", 0).attr("y2", panelH)
          .attr("stroke", T.guide)
          .attr("stroke-width", 1)
          .attr("stroke-dasharray", "6 5");
      });

      // W label
      gP.append("text")
        .attr("x", x(cfg.wL) + 10)
        .attr("y", 14)
        .attr("fill", T.text)
        .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//        .text("W");

      // A label
      gP.append("text")
        .attr("x", 8).attr("y", 18)
        .attr("fill", T.text)
        .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//        .text("A");

      if (mode === "before") {
        // B label + dashed
        gP.append("text")
          .attr("x", 8).attr("y", 34)
          .attr("fill", T.text)
          .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//          .text("B");

        // draw
        gP.append("path")
          .attr("d", lineTopA(topData))
          .attr("fill", "none")
          .attr("stroke", T.ink)
          .attr("stroke-width", 2);

        gP.append("path")
          .attr("d", lineTopB(topData))
          .attr("fill", "none")
          .attr("stroke", T.ink)
          .attr("stroke-width", 2)
          .attr("stroke-dasharray", "8 6");

        // misalignment Δ marker in window (double arrow)
        const yCue = panelH - 14;
        const x1 = x(cfg.wL) + 0.32 * (x(cfg.wR) - x(cfg.wL));
        const x2 = x1 + 0.16 * (x(cfg.wR) - x(cfg.wL));

        gP.append("line")
          .attr("x1", x1).attr("x2", x2)
          .attr("y1", yCue).attr("y2", yCue)
          .attr("stroke", T.cue)
          .attr("stroke-width", 1.6)
          .attr("marker-start", `url(#${uid}-arrow-start)`)
          .attr("marker-end", `url(#${uid}-arrow-end)`);

        gP.append("text")
          .attr("x", x2 + 10)
          .attr("y", yCue + 4)
          .attr("fill", T.text)
          .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//          .text("Δ");
      } else {
        // bottom: show "B (warped)" label and draw it solid (shared timebase cue)
        gP.append("text")
          .attr("x", 8).attr("y", 34)
          .attr("fill", T.text)
          .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//          .text("B (warped)");

        gP.append("path")
          .attr("d", lineBotA(botData))
          .attr("fill", "none")
          .attr("stroke", T.ink)
          .attr("stroke-width", 2);

        gP.append("path")
          .attr("d", lineBotBW(botData))
          .attr("fill", "none")
          .attr("stroke", T.ink)
          .attr("stroke-width", 2);

        // tiny "lock" cue near bottom-right in window (≈)
        gP.append("text")
          .attr("x", x(cfg.wR) - 34)
          .attr("y", panelH - 12)
          .attr("fill", T.text)
          .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//          .text("≈");
      }
    }

    // top panel group
    const gTop = g.append("g");
    drawPanel(gTop, "before");

    // middle label band
    const yMidTop = panelH + gap;
    const gMid = g.append("g").attr("transform", `translate(0, ${yMidTop})`);

    gMid.append("text")
      .attr("x", innerW / 2)
      .attr("y", Math.round(midH * 0.65))
      .attr("text-anchor", "middle")
      .attr("fill", T.text)
      .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//      .text("warp  B(t) → B(t + Δ̂)");

    // bottom panel group
    const yBotTop = yMidTop + midH + gap;
    const gBot = g.append("g").attr("transform", `translate(0, ${yBotTop})`);
    drawPanel(gBot, "after");

    return svg.node();
  }

  function render() {
    const w = Math.floor(host.getBoundingClientRect().width);
    if (!w) return;
    host.innerHTML = "";
    host.appendChild(makeSVG(Math.max(320, w)));
  }

  const ro = new ResizeObserver(() => render());
  ro.observe(host);
  render();
})();
</script>




<script>
(() => {
  const host = document.getElementById("viz-cancel-shared");
  if (!host || typeof d3 === "undefined") return;

  const cfg = {
    xDomain: [0, 10],
    wL: 3.0,
    wR: 7.0,
    aspect: 1563 / 663
  };

  const T = {
    axis:  "rgba(0,0,0,0.45)",
    guide: "rgba(0,0,0,0.35)",
    text:  "rgba(0,0,0,0.70)",
    ink:   "rgba(0,0,0,0.92)",
    win:   "rgba(0,0,0,0.06)"
  };

  // ---- Data (ported from your TikZ coordinate paths) ----
  // Top panel: A (solid) has an extra bump; B (dashed) is the shared-only version.
  const A = [
    [0,0.00],[0.5,0.35],[1.0,0.60],[1.5,0.30],[2.0,-0.20],[2.5,-0.55],[3.0,-0.25],[3.5,0.15],
    [4.0,0.55],[4.5,0.30],[5.0,-0.10],[5.5,-0.38],[6.0,-0.18],[6.2,0.55],[6.4,0.40],[6.6,0.10],
    [7.0,-0.10],[7.5,-0.42],[8.0,-0.20],[8.5,0.22],[9.0,0.55],[9.5,0.25],[10,0.00]
  ];

  const B = [
    [0,0.00],[0.5,0.35],[1.0,0.60],[1.5,0.30],[2.0,-0.20],[2.5,-0.55],[3.0,-0.25],[3.5,0.15],
    [4.0,0.55],[4.5,0.30],[5.0,-0.10],[5.5,-0.38],[6.0,-0.18],[6.2,-0.12],[6.4,-0.05],[6.6,0.05],
    [7.0,-0.10],[7.5,-0.42],[8.0,-0.20],[8.5,0.22],[9.0,0.55],[9.5,0.25],[10,0.00]
  ];

  // Bottom panel: residual is basically “the bump”
  const R = [
    [0,0],[5.3,0],[6.2,0.55],[7.1,0],[10,0]
  ];

  function render() {
    const w = Math.floor(host.getBoundingClientRect().width);
    if (!w) return;

    const width = Math.max(320, w);
    const height = Math.max(260, Math.round(width / cfg.aspect));

    host.innerHTML = "";

    const margin = { top: 16, right: 16, bottom: 16, left: 16 };
    const innerW = width - margin.left - margin.right;
    const innerH = height - margin.top - margin.bottom;

    // 3 rows: top panel, middle label band, bottom panel
    const midH = Math.max(28, Math.round(innerH * 0.14));
    const gap = Math.max(10, Math.round(innerH * 0.06));
    const panelH = Math.round((innerH - midH - 2 * gap) / 2);

    const x = d3.scaleLinear().domain(cfg.xDomain).range([0, innerW]);

    // Use a shared y-scale feel but allow bottom to be a bit taller visually.
    const yTop = d3.scaleLinear().domain([-0.75, 0.75]).range([panelH, 0]);
    const yBot = d3.scaleLinear().domain([-0.15, 0.75]).range([panelH, 0]);

    const svg = d3.create("svg")
      .attr("viewBox", `0 0 ${width} ${height}`)
      .attr("preserveAspectRatio", "xMidYMid meet")
      .attr("role", "img")
//      .attr(
//        "aria-label",
//        "Top: A (solid) and B (dashed) share most of their shape, but A contains an extra bump. Middle: cancel operator A minus B. Bottom: residual shows only the bump, labeled diagnosis."
//      )
      .style("display", "block")
      .style("width", "100%")
      .style("height", "auto");

    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

    const line = (xScale, yScale) => d3.line()
      .x(d => xScale(d[0]))
      .y(d => yScale(d[1]))
      .curve(d3.curveCatmullRom.alpha(0.7));

    function drawFrame(gP, yScale) {
      // window wash
      gP.append("rect")
        .attr("x", x(cfg.wL))
        .attr("y", 0)
        .attr("width", x(cfg.wR) - x(cfg.wL))
        .attr("height", panelH)
        .attr("fill", T.win);

      // rails
      gP.append("line")
        .attr("x1", 0).attr("x2", innerW)
        .attr("y1", 0).attr("y2", 0)
        .attr("stroke", T.axis).attr("stroke-width", 1);

      gP.append("line")
        .attr("x1", 0).attr("x2", innerW)
        .attr("y1", panelH).attr("y2", panelH)
        .attr("stroke", T.axis).attr("stroke-width", 1);

      // guides
      [cfg.wL, cfg.wR].forEach(v => {
        gP.append("line")
          .attr("x1", x(v)).attr("x2", x(v))
          .attr("y1", 0).attr("y2", panelH)
          .attr("stroke", T.guide)
          .attr("stroke-width", 1)
          .attr("stroke-dasharray", "6 5");
      });

      // W label
      gP.append("text")
        .attr("x", x(cfg.wL) + 10)
        .attr("y", 14)
        .attr("fill", T.text)
        .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//        .text("W");
    }

    // ----- TOP PANEL -----
    const gTop = g.append("g");
    drawFrame(gTop, yTop);

    gTop.append("path")
      .attr("d", line(x, yTop)(A))
      .attr("fill", "none")
      .attr("stroke", T.ink)
      .attr("stroke-width", 2);

    gTop.append("path")
      .attr("d", line(x, yTop)(B))
      .attr("fill", "none")
      .attr("stroke", T.ink)
      .attr("stroke-width", 2)
      .attr("stroke-dasharray", "8 6");

    gTop.append("text")
      .attr("x", 8).attr("y", 18)
      .attr("fill", T.text)
      .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//      .text("A");

    gTop.append("text")
      .attr("x", 8).attr("y", 34)
      .attr("fill", T.text)
      .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//      .text("B");

    gTop.append("text")
      .attr("x", x(8.9))
      .attr("y", panelH - 12)
      .attr("fill", T.text)
      .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//      .text("shared");

    // ----- MIDDLE LABEL -----
    const yMidTop = panelH + gap;
    const gMid = g.append("g").attr("transform", `translate(0, ${yMidTop})`);

    gMid.append("text")
      .attr("x", innerW / 2)
      .attr("y", Math.round(midH * 0.65))
      .attr("text-anchor", "middle")
      .attr("fill", T.text)
      .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//      .text("cancel   A − B");

    // ----- BOTTOM PANEL -----
    const yBotTop = yMidTop + midH + gap;
    const gBot = g.append("g").attr("transform", `translate(0, ${yBotTop})`);
    drawFrame(gBot, yBot);

    gBot.append("path")
      .attr("d", line(x, yBot)(R))
      .attr("fill", "none")
      .attr("stroke", T.ink)
      .attr("stroke-width", 2);

    gBot.append("text")
      .attr("x", 8).attr("y", 18)
      .attr("fill", T.text)
      .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//      .text("residual");

    gBot.append("text")
      .attr("x", x(7.9))
      .attr("y", yBot(0.55) - 6)
      .attr("fill", T.text)
      .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//      .text("diagnosis");

    host.appendChild(svg.node());
  }

  const ro = new ResizeObserver(() => render());
  ro.observe(host);
  render();
})();
</script>


<script>
(() => {
  const host = document.getElementById("viz-read-survives");
  if (!host || typeof d3 === "undefined") return;

  const cfg = {
    xDomain: [0, 10],
    wL: 3.0,
    wR: 7.0,
    aspect: 1563 / 663 // same figure ratio as your other steps
  };

  const T = {
    axis:  "rgba(0,0,0,0.45)",
    guide: "rgba(0,0,0,0.35)",
    win:   "rgba(0,0,0,0.06)",
    ink:   "rgba(0,0,0,0.92)",
    text:  "rgba(0,0,0,0.70)",
    faint: "rgba(0,0,0,0.18)"
  };

  // Residual bump (from your TikZ coords)
  const R = [
    [0,0],[5.2,0],[6.2,0.60],[7.2,0],[10,0]
  ];

  function render() {
    const w = Math.floor(host.getBoundingClientRect().width);
    if (!w) return;

    const width = Math.max(320, w);
    const height = Math.max(260, Math.round(width / cfg.aspect));

    host.innerHTML = "";

    const margin = { top: 16, right: 16, bottom: 16, left: 16 };
    const innerW = width - margin.left - margin.right;
    const innerH = height - margin.top - margin.bottom;

    // Match "warp footprint": two stacked panels with the same height
    const gap = Math.max(14, Math.round(innerH * 0.10));
    const panelH = Math.round((innerH - gap) / 2);

    const x = d3.scaleLinear().domain(cfg.xDomain).range([0, innerW]);

    // Top panel y scale (residual is small)
    const yTop = d3.scaleLinear().domain([-0.25, 0.85]).range([panelH, 0]);

    // Bottom panel is "empty", keep a gentle symmetric range for visual calm
    const yBot = d3.scaleLinear().domain([-1, 1]).range([panelH, 0]);

    const svg = d3.create("svg")
      .attr("viewBox", `0 0 ${width} ${height}`)
      .attr("preserveAspectRatio", "xMidYMid meet")
      .attr("role", "img")
      .attr("aria-label", "Top panel: residual after cancel inside window W. Bottom panel: empty placeholder with faint frame and window guides.")
      .style("display", "block")
      .style("width", "100%")
      .style("height", "auto");

    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

    function drawPanelFrame(gP, panelHeight, strong = true) {
      const axisCol  = strong ? T.axis  : T.faint;
      const guideCol = strong ? T.guide : T.faint;

      // window wash
      gP.append("rect")
        .attr("x", x(cfg.wL))
        .attr("y", 0)
        .attr("width", x(cfg.wR) - x(cfg.wL))
        .attr("height", panelHeight)
        .attr("fill", T.win);

      // frame lines
      gP.append("line")
        .attr("x1", 0).attr("x2", innerW)
        .attr("y1", 0).attr("y2", 0)
        .attr("stroke", axisCol).attr("stroke-width", 1);

      gP.append("line")
        .attr("x1", 0).attr("x2", innerW)
        .attr("y1", panelHeight).attr("y2", panelHeight)
        .attr("stroke", axisCol).attr("stroke-width", 1);

      // guides
      [cfg.wL, cfg.wR].forEach(v => {
        gP.append("line")
          .attr("x1", x(v)).attr("x2", x(v))
          .attr("y1", 0).attr("y2", panelHeight)
          .attr("stroke", guideCol)
          .attr("stroke-width", 1)
          .attr("stroke-dasharray", "6 5");
      });

      // W label
      gP.append("text")
        .attr("x", x(cfg.wL) + 10)
        .attr("y", 14)
        .attr("fill", strong ? T.text : "rgba(0,0,0,0.35)")
        .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//        .text("W");
    }

    // ---------- TOP PANEL ----------
    const gTop = g.append("g");
    drawPanelFrame(gTop, panelH, true);

    const line = d3.line()
      .x(d => x(d[0]))
      .y(d => yTop(d[1]))
      .curve(d3.curveCatmullRom.alpha(0.7));

    gTop.append("path")
      .attr("d", line(R))
      .attr("fill", "none")
      .attr("stroke", T.ink)
      .attr("stroke-width", 2);

    gTop.append("text")
      .attr("x", 8)
      .attr("y", 18)
      .attr("fill", T.text)
      .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//      .text("after cancel");

    // ---------- BOTTOM PANEL (faint + empty) ----------
    const gBot = g.append("g").attr("transform", `translate(0, ${panelH + gap})`);
    drawPanelFrame(gBot, panelH, false);

    // optional invisible spacer text to keep vertical feel (mirrors your TikZ)
    gBot.append("text")
      .attr("x", innerW / 2)
      .attr("y", Math.round(panelH * 0.60))
      .attr("text-anchor", "middle")
      .attr("fill", "rgba(0,0,0,0.0)")
      .style("font", "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial")
//      .text(" ");

    host.appendChild(svg.node());
  }

  const ro = new ResizeObserver(() => render());
  ro.observe(host);
  render();
})();
</script>